/* ************************************************************************** */
/** @file [PID.c]
 *  @brief {A PID controller, modified from a PID controller of author Nick Mosher
 * Support all method to implement an turning a PID controller}
 *  @author {bui phuoc}
 * 
/**
 * @author Nick Mosher, <codewhisperer97@gmail.com>
 *
 * A PID Controller is a method of system control in which a correctional output
 * is generated to guide the system toward a desired setpoint (aka target).
 * The PID Controller calculates the output based on the following factors:
 *
 *		Gains (proportional, integral, and derivative)
 *		Target
 *		Feedback
 *
 * The gain values act as multipliers for their corresponding components of PID
 * (more detail later).	The target is the value which the system strives to
 * reach by manipulating the output.	The feedback is the system's actual
 * position or status in regards to the physical world.
 * Another important term in PID is "error", which refers to the difference
 * between the target and the feedback.
 *
 * Each of the three components of PID contributes a unique behavior to the
 * system.
 *
 *		The Proportional component introduces a linear relationship between the
 *		error (target minus feedback) and the output.	This means that as the
 *		feedback grows further away from the target, the output grows
 *		proportionally stronger.
 *
 *				Proportional component = (P Gain) * (target - feedback)
 *
 *		The Integral component is designed to give a very precise approach of the
 *		feedback to the target.	Depending on the scale of the physical system
 *		and the precision of feedback (e.g. sensors), the proportional component
 *		alone is likely not sufficient to provide adequate power (e.g. to motors)
 *		to guide the system in regards to small-scale corrections.	The Integral
 *		component integrates the error of the system (target - feedback) over
 *		time.	If the system reaches a point where it is close but not exactly
 *		on top of the target, the integration will slowly build until it is
 *		powerful enough to overcome static resistances and move the system
 *		preciesly to the target.
 *
 *				Integral component = (I Gain) * Integral of error over time
 *
 *					*In this implementation, Integral is calculated with a running
 *					summation of the system's error, updated at each tick.
 *
 *		The Derivative component measures the rate of change of the feedback.
 *		It can reduce the strength of the output if the feedback is approaching
 *		the target too quickly or if the feedback is moving away from the target.
 *
 *				Derivative component = (D Gain) * ((error - lastError) / time - lastTime)
 *
 * The output generated by the PID Controller is the sum of the three
 * components.
 *
 *		PID output = Proportional component + Integral component + Derivative component
 */
/* ************************************************************************** */


#include <stdlib.h>
#include <stdint.h>
#include "PID.h"

#include "system_config.h"
#include "system_definitions.h"
#include "FreeRTOS.h"
#include "task.h"


/** @brief Constructs the PIDController object with PID Gains and function pointers
 * for retrieving feedback (pidSource) and delivering output (pidOutput).
 * All PID gains should be positive, otherwise the system will violently diverge
 * from the target
 *  @param [in]     PIDController* controller   instance of PID controller
 *                  float p         The Proportional gain
 *                  float i         The Integral gain
 *                  float d         The Derivative gain
 *                  float (*pidSource)  The function pointer for retrieving system feedback.
 *  @param [out]    void (*pidOutput)   The function pointer for delivering system output.
 *  @return None
 */
void PID_CreateController(PIDController* controller, float p, float i, float d, float (*pidSource)(void), void (*pidOutput)(float output)) {
    // Gain
	controller->p = p;
	controller->i = i;
	controller->d = d;
    // Target
	controller->target = 0;
	controller->output = 0;
	controller->enabled = 1;
    // n
	controller->currentFeedback = 0;
    // n-1
	controller->lastFeedback = 0;
	controller->lastError = 0;
	controller->currentTime = 0L;
	controller->lastTime = 0L;
    controller->error = 0;
	controller->integralCumulation = 0;
    controller->cycleDerivative = 0;
	controller->maxCumulation = 70;
	controller->inputBounded = 0;
	controller->outputBounded = 0;
	controller->inputLowerBound = 0;
	controller->inputUpperBound = 0;
	controller->outputBounded = 0;
	controller->outputLowerBound = 0;
	controller->outputUpperBound = 0;
    controller->feedbackWrapped = 0;
	controller->timeFunctionRegistered = 1;
	controller->pidSource = pidSource;
	controller->pidOutput = pidOutput;
	controller->getSystemTime = xTaskGetTickCount;
    controller->Init_integral = 0;
}


/** @brief This method uses the established function pointers to retrieve system
 * feedback, calculate the PID output, and deliver the correction value
 * to the parent of this PIDController.	This method should be run as
 * fast as the source of the feedback in order to provide the highest
 * resolution of control (for example, to be placed in the loop() method)
 *  @param [in]     PIDController *c      instance of PID controller
 *  @param [out]  None
 *  @return None
 */
void PID_Calculate(PIDController *c) {

	if(c->enabled) {
		//Retrieve system feedback from user callback.
		c->currentFeedback = c->pidSource();

		//Apply input bounds if necessary.
		if(c->inputBounded) {
			if(c->currentFeedback > c->inputUpperBound) c->currentFeedback = c->inputUpperBound;
			if(c->currentFeedback < c->inputLowerBound) c->currentFeedback = c->inputLowerBound;
		}

		/*
		 * Feedback wrapping causes two distant numbers to appear adjacent to one
		 * another for the purpose of calculating the system's error.
		 */
		if(c->feedbackWrapped) {

			/*
			 * There are three ways to traverse from one point to another in this setup.
			 *
			 *		1)	Target --> Feedback
			 *
			 * The other two ways involve bridging a gap connected by the upper and
			 * lower bounds of the feedback wrap.
			 *
			 *		2)	Target --> Upper Bound == Lower Bound --> Feedback
			 *
			 *		3)	Target --> Lower Bound == Upper Bound --> Feedback
			 *
			 * Of these three paths, one should always be shorter than the other two,
			 * unless all three are equal, in which case it does not matter which path
			 * is taken.
			 */
			float regErr = c->target - c->currentFeedback;
			float altErr1 = (c->target - c->feedbackWrapLowerBound) + (c->feedbackWrapUpperBound - c->currentFeedback);
			float altErr2 = (c->feedbackWrapUpperBound - c->target) + (c->currentFeedback - c->feedbackWrapLowerBound);

			// Calculate the absolute values of each error.
			float regErrAbs = (regErr >= 0) ? regErr : -regErr;
			float altErr1Abs = (altErr1 >= 0) ? altErr1 : -altErr1;
			float altErr2Abs = (altErr2 >= 0) ? altErr2 : -altErr2;

			// Use the error with the smallest absolute value
			if(regErrAbs <= altErr1Abs && regErr <= altErr2Abs) {
				c->error = regErr;
			}
			else if(altErr1Abs < regErrAbs && altErr1Abs < altErr2Abs) {
				c->error = altErr1Abs;
			}
			else if(altErr2Abs < regErrAbs && altErr2Abs < altErr1Abs) {
				c->error = altErr2Abs;
			}
		}
		else {
			// Calculate the error between the feedback and the target.
			c->error = c->target - c->currentFeedback;
		}

		// If we have a registered way to retrieve the system time, use time in PID calculations.
		if(c->timeFunctionRegistered) {
			// Retrieve system time
			c->currentTime = c->getSystemTime();

			// Calculate time since last tick() cycle.
			long deltaTime = c->currentTime - c->lastTime;
            float fDeltaTime = (float)deltaTime / 1000.0;
			// Calculate the integral of the feedback data since last cycle.
			float cycleIntegral = ((c->lastError + c->error) / 2) * fDeltaTime;        
			// Add this cycle's integral to the integral cumulation.
			c->integralCumulation += cycleIntegral;          
            // Add Init value;
           // c->integralCumulation +=  (c->Init_integral)/(c->i);

           // SYS_PRINT("\n integralCumulation 2 = %f\n", c->integralCumulation); 
			// Calculate the slope of the line with data from the current and last cycles.
			c->cycleDerivative = (c->error - c->lastError) / fDeltaTime;

			// Save time data for next iteration.
			c->lastTime = c->currentTime;
		}
		// If we have no way to retrieve system time, estimate calculations.
		else {
			c->integralCumulation += c->error;
			c->cycleDerivative = (c->error - c->lastError);
		}
		// Prevent the integral cumulation from becoming overwhelmingly huge.
        float integral = c->integralCumulation;
		if(c->integralCumulation > c->maxCumulation) c->integralCumulation = c->maxCumulation;
		if(c->integralCumulation < -c->maxCumulation) c->integralCumulation = -c->maxCumulation;
        
		// Calculate the system output based on data and PID gains.
		c->output = (float) ((c->error * c->p) + (c->integralCumulation * c->i) + (c->cycleDerivative * c->d));
       
		// Save a record of this iteration's data.
		c->lastFeedback = c->currentFeedback;
		c->lastError = c->error;
		// Trim the output to the bounds if needed.
		if(c->outputBounded) {
			if(c->output > c->outputUpperBound) c->output = c->outputUpperBound;
			if(c->output < c->outputLowerBound) c->output = c->outputLowerBound;
		}
		c->pidOutput(c->output);
        
	}
}

/** @brief Enables or disables this PIDController
 *  @param [in]     PIDController *controller    instance of PID controller
 *                  uint8_t enabled     True to enable, False to disable
 *  @param [out]  None
 *  @return None
 */

void PID_SetEnabled(PIDController *controller, uint8_t enabled) {

	// If the PIDController was enabled and is being disabled.
	if(enabled && !controller->enabled) {
		controller->output = 0;
		controller->integralCumulation = 0;
        controller->cycleDerivative = 0;
        controller->lastError = 0;
        controller->error = 0;
	}
    controller->lastTime = controller->getSystemTime();
	controller->enabled = enabled;
}

/** @brief Returns the value that the Proportional component is contributing to the output
 *  @param [in]     PIDController *controller    instance of PID controller
 *  @param [out]  None
 *  @return     float   The value that the Proportional component is contributing to the output.
 */
float PID_GetProportionalComponent(PIDController *controller) {
	return (controller->error * controller->p);
}

/** @brief Returns the value that the Integral component is contributing to the output.
 *  @param [in]     PIDController *controller    instance of PID controller
 *  @param [out]  None
 *  @return     float   The value that the Integral component is contributing to the output.
 */
float PID_GetIntegralComponent(PIDController *controller) {
	return (controller->integralCumulation * controller->i);
}


/** @brief Returns the value that the Derivative component is contributing to the output.
 *  @param [in]     PIDController *controller    instance of PID controller
 *  @param [out]  None
 *  @return     float   The value that the Derivative component is contributing to the output.
 */
float PID_GetDerivativeComponent(PIDController *controller) {
	return (controller->cycleDerivative * controller->d);
}


/** @brief Sets the maximum value that the integral cumulation can reach.
 *  @param [in]     PIDController *controller    instance of PID controller
 *                  float max       max The maximum value of the integral cumulation.
 *  @param [out]  None
 *  @return     None
 */
void PID_SetMaxIntegralCumulation(PIDController *controller, float max) {

	// If the new max value is less than 0, invert to make positive.
	if(max < 0) {
		max = -max;
	}

	// If the new max is not more than 1 then the cumulation is useless.
	if(max > 1) {
		controller->maxCumulation = max;
	}
}


/** @brief Sets bounds which limit the lower and upper extremes that this PIDController
 * accepts as inputs.	Outliers are trimmed to the lower and upper bounds.
 * Setting input bounds automatically enables input bounds.
 *  @param [in]     PIDController *controller    instance of PID controller
 *                  float lower     The lower input bound.
 *                  float upper     The upper input bound.
 *  @param [out]  None
 *  @return     None
 */
void PID_SetInputBounds(PIDController *controller, float lower, float upper) {

	if(upper > lower) {
		controller->inputBounded = 1;
		controller->inputUpperBound = upper;
		controller->inputLowerBound = lower;
	}
}


/** @brief Sets bounds which limit the lower and upper extremes that this PIDController
 * will ever generate as output. Setting output bounds automatically enables
 * output bounds.
 *  @param [in]     PIDController *controller    instance of PID controller
 *                  float lower     The lower output bound.
 *                  float upper     The upper output bound.
 *  @param [out]  None
 *  @return     None
 */
void PID_SetOutputBounds(PIDController *controller, float lower, float upper) {

	if(upper > lower) {
		controller->outputBounded = 1;
		controller->outputLowerBound = lower;
		controller->outputUpperBound = upper;
	}
}


/** @brief Sets the bounds which the feedback wraps around. This
 * also enables Input Bounds at the same coordinates to
 * prevent extraneous domain errors.
 *  @param [in]     PIDController *controller    instance of PID controller
 *                  float lower     The lower wrap bound.
 *                  float upper     The upper wrap bound.
 *  @param [out]  None
 *  @return     None
 */
void PID_SetFeedbackWrapBounds(PIDController *controller, float lower, float upper) {

	// Make sure no value outside this circular range is ever input.
	PID_SetInputBounds(controller, lower, upper);

	controller->feedbackWrapped = 1;
	controller->feedbackWrapLowerBound = lower;
	controller->feedbackWrapUpperBound = upper;
}


void PID_SetIntegral_Init(PIDController *controller, float initValue){
    controller->Init_integral = initValue;
}